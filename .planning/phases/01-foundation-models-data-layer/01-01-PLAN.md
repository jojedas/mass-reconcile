---
phase: 01-foundation-models-data-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - __init__.py
  - __manifest__.py
  - models/__init__.py
  - models/mass_reconcile_batch.py
  - models/account_bank_statement_line.py
  - models/mass_reconcile_match.py
autonomous: true

must_haves:
  truths:
    - "mass.reconcile.batch can be created with states draft/matching/review/reconciled"
    - "account.bank.statement.line has batch_id, match_score, and suggested_move_id fields"
    - "mass.reconcile.match stores proposals with statement_line_id, suggested_move_id, match_score, match_reason, and audit fields"
    - "State transitions on batch are enforced via button methods with validation"
    - "Computed fields use _read_group for batch performance (no N+1 queries)"
    - "All field definitions use public Odoo API (fields.*, models.Model)"
  artifacts:
    - path: "__init__.py"
      provides: "Module root init importing models package"
      contains: "from . import models"
    - path: "__manifest__.py"
      provides: "Module metadata with name, version, depends, data files"
      contains: "mass_reconcile"
    - path: "models/__init__.py"
      provides: "Models package init importing all model files"
      contains: "mass_reconcile_batch"
    - path: "models/mass_reconcile_batch.py"
      provides: "Batch model with state machine, mail.thread, computed fields"
      contains: "class MassReconcileBatch"
      min_lines: 60
    - path: "models/account_bank_statement_line.py"
      provides: "Extension of bank statement line with batch and match fields"
      contains: "_inherit = 'account.bank.statement.line'"
      min_lines: 15
    - path: "models/mass_reconcile_match.py"
      provides: "Match proposal model with score, reason, and SQL constraints"
      contains: "class MassReconcileMatch"
      min_lines: 40
  key_links:
    - from: "models/mass_reconcile_batch.py"
      to: "models/account_bank_statement_line.py"
      via: "One2many statement_line_ids -> batch_id Many2one"
      pattern: "statement_line_ids.*One2many.*account.bank.statement.line.*batch_id"
    - from: "models/mass_reconcile_match.py"
      to: "models/mass_reconcile_batch.py"
      via: "Many2one batch_id linking match to batch"
      pattern: "batch_id.*Many2one.*mass.reconcile.batch"
    - from: "models/mass_reconcile_match.py"
      to: "models/account_bank_statement_line.py"
      via: "Many2one statement_line_id linking match to statement line"
      pattern: "statement_line_id.*Many2one.*account.bank.statement.line"
---

<objective>
Create the Odoo module scaffold and all three data models for mass bank reconciliation: the batch model with state machine, the statement line extension with match fields, and the match proposal model with audit trail.

Purpose: Establish the complete data layer foundation so that subsequent phases (matching engine, batch processing, UI) have stable models to build upon.
Output: A valid Odoo 18.0 module with three model definitions, proper ORM patterns, and all relational links between models.
</objective>

<execution_context>
@/home/jojeda/.claude/get-shit-done/workflows/execute-plan.md
@/home/jojeda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-models-data-layer/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create module scaffold and batch model with state machine</name>
  <files>
    __init__.py
    __manifest__.py
    models/__init__.py
    models/mass_reconcile_batch.py
  </files>
  <action>
    1. Create `__init__.py` at module root with `from . import models`.

    2. Create `__manifest__.py` with:
       - name: "Mass Bank Reconciliation"
       - version: "18.0.1.0.0"
       - category: "Accounting"
       - summary: "Automate mass bank statement reconciliation with confidence scoring"
       - depends: ['account', 'mail']
       - data: [] (empty for now, Plan 02 will add security files)
       - license: "LGPL-3"
       - installable: True
       - application: True

    3. Create `models/__init__.py` importing all three model modules:
       ```python
       from . import mass_reconcile_batch
       from . import account_bank_statement_line
       from . import mass_reconcile_match
       ```

    4. Create `models/mass_reconcile_batch.py` with class MassReconcileBatch:
       - _name = 'mass.reconcile.batch'
       - _description = 'Mass Reconciliation Batch'
       - _inherit = ['mail.thread'] (for audit trail via chatter)
       - _order = 'create_date desc'

       Fields:
       - name: Char, required=True, tracking=True
       - state: Selection with choices [('draft', 'Draft'), ('matching', 'Matching'), ('review', 'Review'), ('reconciled', 'Reconciled')], default='draft', required=True, tracking=True
       - company_id: Many2one to 'res.company', required=True, default=lambda self: self.env.company
       - user_id: Many2one to 'res.users', string='Responsible', default=lambda self: self.env.user, tracking=True
       - journal_id: Many2one to 'account.journal', string='Bank Journal', domain="[('type', '=', 'bank')]", help='Bank journal for this reconciliation batch'
       - statement_line_ids: One2many to 'account.bank.statement.line' via 'batch_id'
       - match_ids: One2many to 'mass.reconcile.match' via 'batch_id'
       - date_from: Date, string='Date From', help='Start date filter for statement lines'
       - date_to: Date, string='Date To', help='End date filter for statement lines'
       - notes: Text, string='Notes'

       Computed fields (use _read_group for batch performance per DATA-04):
       - line_count: Integer, compute='_compute_line_count', store=True
       - match_count: Integer, compute='_compute_match_count', store=True
       - matched_percentage: Float, compute='_compute_matched_percentage' (non-stored, derived from line_count and match_count)

       _compute_line_count: Use _read_group on account.bank.statement.line with domain [('batch_id', 'in', self.ids)], grouping by batch_id and __count. Map results to each batch. Handle empty recordset.

       _compute_match_count: Same pattern with mass.reconcile.match.

       _compute_matched_percentage: Simple division (match_count / line_count * 100) with zero-division guard.

       SQL constraints:
       - ('name_company_unique', 'UNIQUE(name, company_id)', 'Batch name must be unique per company')

       Python constraints (@api.constrains):
       - _check_dates: If both date_from and date_to are set, date_from must be <= date_to
       - _check_reconcile_requirements: Cannot set state='reconciled' with line_count == 0

       State transition button methods:
       - action_start_matching(self): ensure_one(), validate line_count > 0, write state='matching'
       - action_move_to_review(self): write state='review'
       - action_reconcile(self): ensure_one(), write state='reconciled'
       - action_reset_to_draft(self): write state='draft'

       All methods use self.write({'state': ...}) pattern (not direct assignment) for proper tracking.
       All use only public Odoo APIs per DATA-07.
       Do NOT include mail.activity.mixin (not needed in Phase 1 per research open questions).
  </action>
  <verify>
    Run: `python -c "import ast; ast.parse(open('models/mass_reconcile_batch.py').read()); print('SYNTAX OK')"` from module root.
    Run: `python -c "import ast; ast.parse(open('__manifest__.py').read()); print('MANIFEST OK')"` from module root.
    Verify the file contains: class MassReconcileBatch, _name = 'mass.reconcile.batch', state field with all 4 selections, _read_group usage in computed fields.
  </verify>
  <done>
    Module scaffold exists with __init__.py, __manifest__.py, models/__init__.py. Batch model has state machine (draft/matching/review/reconciled), mail.thread mixin, computed fields using _read_group, SQL and Python constraints, and state transition methods. All code uses public Odoo APIs only.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create statement line extension and match proposal model</name>
  <files>
    models/account_bank_statement_line.py
    models/mass_reconcile_match.py
  </files>
  <action>
    1. Create `models/account_bank_statement_line.py` with class AccountBankStatementLine:
       - _inherit = 'account.bank.statement.line' (extension, NO new _name)

       Fields:
       - batch_id: Many2one to 'mass.reconcile.batch', string='Reconciliation Batch', index=True, ondelete='set null', help='Mass reconciliation batch this line belongs to'
       - match_score: Float, string='Match Score', help='Confidence score for best suggested match (0-100)', digits=(5, 2)
       - suggested_move_id: Many2one to 'account.move', string='Suggested Move', help='Best suggested accounting move for reconciliation', ondelete='set null'
       - match_state: Selection with choices [('unmatched', 'Unmatched'), ('matched', 'Matched'), ('reviewed', 'Reviewed'), ('reconciled', 'Reconciled')], default='unmatched', string='Match State', help='Current state of this line in the reconciliation process'

       No constraints on this extension (constraints belong to the match model and batch model).
       No computed fields here -- match_score is written directly by the matching engine (Phase 2).

    2. Create `models/mass_reconcile_match.py` with class MassReconcileMatch:
       - _name = 'mass.reconcile.match'
       - _description = 'Mass Reconciliation Match Proposal'
       - _order = 'match_score desc, create_date desc'

       Fields:
       - batch_id: Many2one to 'mass.reconcile.batch', string='Batch', required=True, ondelete='cascade', index=True
       - statement_line_id: Many2one to 'account.bank.statement.line', string='Statement Line', required=True, ondelete='cascade', index=True
       - suggested_move_id: Many2one to 'account.move', string='Suggested Move', required=True, ondelete='restrict'
       - suggested_move_line_id: Many2one to 'account.move.line', string='Suggested Move Line', ondelete='restrict', help='Specific journal item for reconciliation'
       - match_score: Float, string='Match Score', required=True, help='Confidence score (0-100)', digits=(5, 2)
       - match_reason: Text, string='Match Reason', help='Explanation of why this match was suggested (e.g., exact amount + reference match)'
       - match_type: Selection with choices [('exact', 'Exact Match'), ('partial', 'Partial Match'), ('manual', 'Manual Match')], string='Match Type', required=True, default='exact'
       - is_selected: Boolean, string='Selected', default=False, help='Whether this proposal has been selected for reconciliation'

       Audit fields (automatic via Odoo ORM -- create_uid, create_date, write_uid, write_date are built-in):
       - Do NOT redeclare create_uid/create_date. Odoo provides these automatically via _log_access=True (default).
       - Add comment noting audit fields are provided by ORM.

       SQL constraints:
       - ('check_score_range', 'CHECK(match_score >= 0 AND match_score <= 100)', 'Match score must be between 0 and 100')
       - ('unique_match', 'UNIQUE(statement_line_id, suggested_move_id)', 'Cannot suggest the same move multiple times for one statement line')

       Python constraints:
       - @api.constrains('match_score'): Validate 0 <= match_score <= 100 with proper ValidationError message
       - @api.constrains('statement_line_id', 'batch_id'): Validate that statement_line_id.batch_id matches self.batch_id (referential integrity within batch)

       Use only public Odoo APIs per DATA-07.
  </action>
  <verify>
    Run: `python -c "import ast; ast.parse(open('models/account_bank_statement_line.py').read()); print('SYNTAX OK')"` from module root.
    Run: `python -c "import ast; ast.parse(open('models/mass_reconcile_match.py').read()); print('SYNTAX OK')"` from module root.
    Verify account_bank_statement_line.py contains: _inherit = 'account.bank.statement.line', batch_id, match_score, suggested_move_id fields.
    Verify mass_reconcile_match.py contains: _name = 'mass.reconcile.match', SQL constraints for score range and unique match, @api.constrains decorators.
  </verify>
  <done>
    Statement line extension adds batch_id (Many2one with index), match_score (Float), suggested_move_id (Many2one), and match_state (Selection) to account.bank.statement.line. Match proposal model stores proposals with batch/statement_line/move links, score with SQL range constraint, unique constraint preventing duplicate proposals, match_reason for audit trail, and referential integrity constraint. All code uses public Odoo APIs only.
  </done>
</task>

</tasks>

<verification>
1. All Python files pass syntax check via `python -c "import ast; ast.parse(...)"`
2. Module __manifest__.py is valid Python dict with correct depends ['account', 'mail']
3. models/__init__.py imports all three model modules
4. mass_reconcile_batch.py defines state machine with 4 states and transition methods
5. account_bank_statement_line.py extends (not replaces) existing model via _inherit
6. mass_reconcile_match.py has SQL constraints and Python constraints
7. No private Odoo APIs used (no _cr.execute, no underscore-prefixed method calls beyond standard ORM)
8. Computed fields use _read_group pattern (not search_count in loops)
</verification>

<success_criteria>
- Module scaffold is a valid Odoo 18.0 module structure
- Three model definitions compile without syntax errors
- Batch model has complete state machine (draft -> matching -> review -> reconciled)
- Statement line extension adds 4 fields without breaking existing model
- Match model has SQL constraints, Python constraints, and audit trail
- All computed fields follow _read_group batch pattern
- All relational links (One2many/Many2one) are bidirectional and correct
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-models-data-layer/01-01-SUMMARY.md`
</output>
