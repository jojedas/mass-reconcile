---
phase: 02-matching-engine-auto-reconciliation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - models/mass_reconcile_batch.py
  - models/mass_reconcile_engine.py
  - security/ir.model.access.csv
  - __manifest__.py
autonomous: true

must_haves:
  truths:
    - "Batch action_start_matching invokes matching engine for all statement lines and creates match proposals"
    - "Engine integrates with account.reconcile.model to apply existing reconciliation rules"
    - "Match proposals are created in mass.reconcile.match with correct scores and classifications"
    - "Batch transitions to review state after matching completes"
    - "Statement lines update match_state based on best match score"
  artifacts:
    - path: "models/mass_reconcile_batch.py"
      provides: "Batch orchestration calling engine and creating proposals"
      contains: "action_start_matching"
    - path: "models/mass_reconcile_engine.py"
      provides: "Reconcile model integration method"
      contains: "_apply_reconcile_models"
  key_links:
    - from: "models/mass_reconcile_batch.py"
      to: "models/mass_reconcile_engine.py"
      via: "engine invocation from batch"
      pattern: "env\\['mass\\.reconcile\\.engine'\\]"
    - from: "models/mass_reconcile_batch.py"
      to: "models/mass_reconcile_match.py"
      via: "match proposal creation from engine results"
      pattern: "env\\['mass\\.reconcile\\.match'\\]\\.create"
    - from: "models/mass_reconcile_engine.py"
      to: "account.reconcile.model"
      via: "querying existing reconciliation rules"
      pattern: "env\\['account\\.reconcile\\.model'\\]"
---

<objective>
Wire the matching engine into the batch orchestration flow and integrate with account.reconcile.model for recurring expense matching. When a user clicks "Start Matching" on a batch, the system invokes the engine for each statement line, creates mass.reconcile.match proposals with scores and classifications, updates statement line match_state, and transitions the batch to review state.

Purpose: Without batch integration, the engine is isolated logic with no entry point. Without reconcile model integration, recurring expenses (rent, utilities, salaries) that already have Odoo rules configured won't benefit from those rules. This plan connects the algorithm to the user workflow.

Output: Updated batch model with full matching orchestration, engine with reconcile model integration, updated security for any new model access needs.
</objective>

<execution_context>
@/home/jojeda/.claude/get-shit-done/workflows/execute-plan.md
@/home/jojeda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-matching-engine-auto-reconciliation/02-01-SUMMARY.md
@.planning/phases/02-matching-engine-auto-reconciliation/02-RESEARCH.md
@models/mass_reconcile_batch.py
@models/mass_reconcile_match.py
@models/mass_reconcile_engine.py
@models/mass_reconcile_scorer.py
@models/account_bank_statement_line.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire matching engine into batch orchestration and create match proposals</name>
  <files>
    models/mass_reconcile_batch.py
    models/mass_reconcile_engine.py
  </files>
  <action>
    **Update mass_reconcile_batch.py - `action_start_matching` method:**

    Replace the current stub with full orchestration logic:

    1. Set state to 'matching' at start
    2. Delete any existing match proposals for this batch (re-matching scenario):
       `self.match_ids.unlink()`
    3. Reset all statement line match_states to 'unmatched'
    4. Get the engine: `engine = self.env['mass.reconcile.engine']`
    5. Process each statement line:
       ```python
       for line in self.statement_line_ids:
           candidates = engine.find_candidates(line)
           # Also check reconcile models
           model_candidates = engine.apply_reconcile_models(line)
           all_candidates = candidates + model_candidates
           if all_candidates:
               self._create_match_proposals(line, all_candidates)
       ```
    6. After processing all lines, transition to 'review' state
    7. Post a message to the chatter summarizing results:
       - Total lines processed
       - Matches found (safe/probable/doubtful counts)
       - Unmatched lines count

    **Add `_create_match_proposals` method to batch model:**

    Takes a statement line and list of candidate dicts `[{move_line_id, score, match_type, reason}]`:
    1. For each candidate, create a mass.reconcile.match record:
       - batch_id: self.id
       - statement_line_id: line.id
       - suggested_move_id: move_line.move_id.id (parent move of the move line)
       - suggested_move_line_id: candidate['move_line_id']
       - match_score: candidate['score']
       - match_type: 'exact' if score==100 else 'partial'
       - match_reason: candidate['reason']
    2. Use batch create (single `self.env['mass.reconcile.match'].create(vals_list)`) for performance
    3. Update statement line with best match:
       - line.match_score = max score among candidates
       - line.suggested_move_id = move of highest-scored candidate
       - line.match_state = 'matched'

    **Add `apply_reconcile_models` method to engine (mass_reconcile_engine.py):**

    Integrates with account.reconcile.model (MATCH-12):
    1. Search for applicable reconciliation models:
       ```python
       models = self.env['account.reconcile.model'].search([
           ('rule_type', '=', 'invoice_matching'),
           ('company_id', '=', statement_line.company_id.id),
       ])
       ```
    2. For each model, check if it matches the statement line based on:
       - match_partner: if model requires partner match, verify partner matches
       - match_label: if model has label matching, compare against payment_ref
       - match_amount: if model specifies amount matching, verify within tolerance
    3. Return candidates in same dict format as find_candidates
    4. Use try/except around the entire method -- if account.reconcile.model doesn't exist (OCA module not installed), return empty list gracefully:
       ```python
       try:
           models = self.env['account.reconcile.model'].search(...)
       except Exception:
           return []
       ```
    5. Score reconcile model matches at 90 (probable) since they're rule-based but not exact.

    **Important:** Do NOT use `self.env.ref()` or hardcoded XML IDs for reconcile models. Search dynamically.
  </action>
  <verify>
    ```bash
    # Syntax check
    python -c "import ast; ast.parse(open('models/mass_reconcile_batch.py').read()); print('batch OK')"
    python -c "import ast; ast.parse(open('models/mass_reconcile_engine.py').read()); print('engine OK')"

    # Verify engine is called from batch
    grep -n "mass.reconcile.engine" models/mass_reconcile_batch.py

    # Verify match proposals are created
    grep -n "mass.reconcile.match" models/mass_reconcile_batch.py

    # Verify reconcile model integration
    grep -n "account.reconcile.model" models/mass_reconcile_engine.py

    # Verify batch create pattern (not create in loop)
    grep -n "\.create(" models/mass_reconcile_batch.py
    ```
  </verify>
  <done>
    - action_start_matching processes all statement lines through engine and creates match proposals
    - _create_match_proposals uses batch create for performance
    - Statement lines get updated match_state and best match score
    - Batch transitions to review state after matching
    - Chatter message posted with matching summary
    - apply_reconcile_models gracefully handles missing OCA module
  </done>
</task>

<task type="auto">
  <name>Task 2: Add match_type values for engine output and update security</name>
  <files>
    models/mass_reconcile_match.py
    security/ir.model.access.csv
  </files>
  <action>
    **Update mass_reconcile_match.py - extend match_type selection:**

    The current match_type has: exact, partial, manual. Add new types needed by the engine:
    ```python
    match_type = fields.Selection(
        selection=[
            ('exact', 'Exact Match'),
            ('partial', 'Partial Match'),
            ('manual', 'Manual Match'),
            ('internal_transfer', 'Internal Transfer'),
            ('reconcile_model', 'Reconcile Model Rule'),
        ],
        ...
    )
    ```

    Add a `confidence_class` computed field for UI convenience (MATCH-07, 08, 09):
    ```python
    confidence_class = fields.Selection(
        selection=[
            ('safe', 'Safe'),
            ('probable', 'Probable'),
            ('doubtful', 'Doubtful'),
        ],
        string='Confidence Class',
        compute='_compute_confidence_class',
        store=True,
        help='Classification based on match score: safe (100), probable (80-99), doubtful (<80)'
    )

    @api.depends('match_score')
    def _compute_confidence_class(self):
        scorer = self.env['mass.reconcile.scorer']
        for record in self:
            record.confidence_class = scorer.classify_match(record.match_score)
    ```

    **Verify security/ir.model.access.csv:**

    Check that the existing CSV covers the engine and scorer models. Since they are AbstractModels (no database table), they do NOT need access rights entries. Verify this assumption is correct and document it with a comment if needed. No changes expected to CSV unless engine/scorer are changed to regular models.

    **Note:** If during Plan 01 the engine or scorer were implemented as regular models.Model instead of AbstractModel, add access rights entries following the same pattern as batch and match (user=RWC, manager=RWCD).
  </action>
  <verify>
    ```bash
    # Syntax check
    python -c "import ast; ast.parse(open('models/mass_reconcile_match.py').read()); print('match OK')"

    # Verify new match types
    grep -n "internal_transfer\|reconcile_model" models/mass_reconcile_match.py

    # Verify confidence_class field
    grep -n "confidence_class" models/mass_reconcile_match.py

    # Verify scorer is called
    grep -n "mass.reconcile.scorer\|classify_match" models/mass_reconcile_match.py

    # Check CSV is valid (header + data rows)
    head -5 security/ir.model.access.csv
    ```
  </verify>
  <done>
    - match_type selection includes internal_transfer and reconcile_model types
    - confidence_class computed field classifies matches as safe/probable/doubtful
    - Security CSV covers all database-backed models (AbstractModels excluded)
    - All Python files pass syntax check
  </done>
</task>

</tasks>

<verification>
```bash
# All files syntax-valid
for f in models/mass_reconcile_batch.py models/mass_reconcile_engine.py models/mass_reconcile_scorer.py models/mass_reconcile_match.py models/account_bank_statement_line.py; do
  python -c "import ast; ast.parse(open('$f').read()); print('OK: $f')"
done

# Engine is called from batch
grep -c "mass.reconcile.engine" models/mass_reconcile_batch.py  # Should be >= 1

# Reconcile model integration exists
grep -c "account.reconcile.model" models/mass_reconcile_engine.py  # Should be >= 1

# Match proposals created with batch create
grep "\.create(" models/mass_reconcile_batch.py | grep -v "def "  # Should show create call

# Confidence classification works
grep -c "confidence_class" models/mass_reconcile_match.py  # Should be >= 2
```
</verification>

<success_criteria>
- Batch action_start_matching calls engine.find_candidates for each statement line
- Match proposals are batch-created in mass.reconcile.match with correct scores
- Statement lines get match_state updated to 'matched' when candidates found
- Batch transitions from matching to review after processing completes
- Reconcile model integration works when OCA module installed, gracefully degrades when not
- Match model has confidence_class computed field (safe/probable/doubtful)
- Match model supports internal_transfer and reconcile_model match types
- All Python files pass syntax validation
</success_criteria>

<output>
After completion, create `.planning/phases/02-matching-engine-auto-reconciliation/02-02-SUMMARY.md`
</output>
