---
phase: 03-batch-processing-state-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - models/mass_reconcile_batch.py
autonomous: true

must_haves:
  truths:
    - "User can load up to 80 unreconciled statement lines into a batch by date range"
    - "System warns user when more lines exist than the 80-line limit"
    - "Concurrent users cannot process the same batch simultaneously"
    - "State transitions are guarded - invalid transitions raise clear errors"
    - "Reset to draft cleans up all match proposals and resets line states"
  artifacts:
    - path: "models/mass_reconcile_batch.py"
      provides: "Line loading, locking, state guards, reset cleanup"
      contains: "action_load_statement_lines"
  key_links:
    - from: "models/mass_reconcile_batch.py"
      to: "account.bank.statement.line"
      via: "domain search with date range + 80-line LIMIT"
      pattern: "search\\(domain.*limit=80"
    - from: "models/mass_reconcile_batch.py"
      to: "PostgreSQL"
      via: "SELECT FOR UPDATE NOWAIT"
      pattern: "FOR UPDATE NOWAIT"
---

<objective>
Add statement line loading with 80-line chunking and date range selection, concurrency control via SELECT FOR UPDATE NOWAIT, state transition validation guards, and draft reset cleanup to mass.reconcile.batch.

Purpose: Enable safe batch creation and processing with proper limits, locking, and state integrity.
Output: Enhanced mass_reconcile_batch.py with line loading, locking, guards, and cleanup methods.
</objective>

<execution_context>
@/home/jojeda/.claude/get-shit-done/workflows/execute-plan.md
@/home/jojeda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-batch-processing-state-management/03-RESEARCH.md
@.planning/phases/02-matching-engine-auto-reconciliation/02-02-SUMMARY.md
@models/mass_reconcile_batch.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add action_load_statement_lines with date range and 80-line limit</name>
  <files>models/mass_reconcile_batch.py</files>
  <action>
Add method `action_load_statement_lines` to MassReconcileBatch class. This method:

1. Call `self.ensure_one()` and validate state is 'draft' (raise ValidationError otherwise).
2. Require `journal_id` to be set (raise UserError "Please select a bank journal before loading lines").
3. Build domain:
   - `('journal_id', '=', self.journal_id.id)`
   - `('is_reconciled', '=', False)`
   - `('batch_id', '=', False)` â€” not already in another batch
   - If `self.date_from`: append `('date', '>=', self.date_from)`
   - If `self.date_to`: append `('date', '<=', self.date_to)`
4. Count total available with `search_count(domain)`.
5. If count == 0, raise UserError "No unreconciled statement lines found for the selected criteria."
6. Search with `limit=80, order='date asc'` to get lines.
7. Write `{'batch_id': self.id}` to assign lines to batch.
8. Return `ir.actions.client` notification:
   - If total_available > 80: warning type, sticky=True, message: f"Loaded first 80 of {total_available} available lines. Create additional batches for remaining lines."
   - Else: success type, sticky=False, message: f"{len(lines)} statement lines loaded into batch."

Add `from odoo.exceptions import UserError` to imports (keep existing ValidationError import).
  </action>
  <verify>
Run: `python3 -c "import ast; ast.parse(open('models/mass_reconcile_batch.py').read()); print('OK')"`
Verify: `grep -c 'action_load_statement_lines' models/mass_reconcile_batch.py` returns >= 1
Verify: `grep -c 'limit=80' models/mass_reconcile_batch.py` returns >= 1
Verify: `grep -c 'UserError' models/mass_reconcile_batch.py` returns >= 1
  </verify>
  <done>
action_load_statement_lines method exists with: domain filtering by journal/date/reconciliation status, search_count before loading, 80-line LIMIT, proper user notification for overflow, UserError for empty results.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add SELECT FOR UPDATE locking + state validation guards + reset cleanup</name>
  <files>models/mass_reconcile_batch.py</files>
  <action>
Three changes to MassReconcileBatch:

**A. Locking helper method `_lock_batch_for_update`:**
Create private method that:
1. Flushes batch model state field: `self.env['mass.reconcile.batch'].flush_model(['state'])`
2. Executes: `SELECT id FROM mass_reconcile_batch WHERE id = %s FOR UPDATE NOWAIT` with `(self.id,)`
3. Wrap in try/except: if exception message contains 'could not obtain lock' (case-insensitive), raise UserError "This batch is currently being processed by another user. Please try again in a few moments."
4. Re-raise any other exception.

**B. Harden action_start_matching:**
At the beginning of existing `action_start_matching`, BEFORE the current `if self.line_count == 0` check:
1. Add: `if self.state != 'draft': raise ValidationError("Can only start matching from draft state.")`
2. Add: `self._lock_batch_for_update()`
(The rest of the existing method remains unchanged.)

**C. Harden action_reconcile:**
Replace current simple action_reconcile with:
1. `self.ensure_one()`
2. Validate state is 'review': `if self.state != 'review': raise ValidationError("Can only reconcile from review state.")`
3. Call `self._lock_batch_for_update()`
4. Write state to 'reconciled': `self.write({'state': 'reconciled'})`
5. Post chatter message: `self.message_post(body="<p>Batch reconciliation completed.</p>", subject='Reconciliation Complete')`

**D. Harden action_move_to_review:**
Add validation: `if self.state != 'matching': raise ValidationError("Can only move to review from matching state.")`

**E. Enhance action_reset_to_draft:**
Replace current simple reset with:
1. `self.ensure_one()`
2. Validate state is NOT 'reconciled': `if self.state == 'reconciled': raise ValidationError("Cannot reset a reconciled batch. Use undo reconciliation instead.")`
3. Delete match proposals: `self.match_ids.unlink()`
4. Reset statement lines: `self.statement_line_ids.write({'match_state': 'unmatched', 'match_score': 0, 'suggested_move_id': False})`
5. Unassign lines from batch: `self.statement_line_ids.write({'batch_id': False})`
6. Set state: `self.write({'state': 'draft'})`
7. Post chatter: `self.message_post(body="<p>Batch reset to draft. All lines unassigned and proposals deleted.</p>", subject='Reset to Draft')`

Import `logging` at top of file and add `_logger = logging.getLogger(__name__)` after imports.
  </action>
  <verify>
Run: `python3 -c "import ast; ast.parse(open('models/mass_reconcile_batch.py').read()); print('OK')"`
Verify: `grep -c 'FOR UPDATE NOWAIT' models/mass_reconcile_batch.py` returns >= 1
Verify: `grep -c '_lock_batch_for_update' models/mass_reconcile_batch.py` returns >= 2 (definition + call sites)
Verify: `grep -c "state != 'draft'" models/mass_reconcile_batch.py` returns >= 1
Verify: `grep -c "state != 'review'" models/mass_reconcile_batch.py` returns >= 1
Verify: `grep "action_reset_to_draft" models/mass_reconcile_batch.py | head -1` shows method exists
  </verify>
  <done>
_lock_batch_for_update private method with SELECT FOR UPDATE NOWAIT and flush; action_start_matching guarded with state=='draft' check and lock; action_reconcile guarded with state=='review' check, lock, and chatter post; action_move_to_review guarded with state=='matching' check; action_reset_to_draft performs full cleanup (unlink proposals, reset line fields, unassign lines, chatter post).
  </done>
</task>

</tasks>

<verification>
1. `python3 -c "import ast; ast.parse(open('models/mass_reconcile_batch.py').read()); print('SYNTAX OK')"` passes
2. `grep 'action_load_statement_lines\|_lock_batch_for_update\|FOR UPDATE NOWAIT' models/mass_reconcile_batch.py` shows all three patterns
3. State guards exist for all transitions: draft->matching, matching->review, review->reconciled
4. Reset cleanup unlinks proposals, resets line states, and unassigns lines from batch
5. 80-line limit enforced via search(limit=80)
</verification>

<success_criteria>
- action_load_statement_lines searches by journal/date range with LIMIT 80
- User sees warning notification when more than 80 lines available
- SELECT FOR UPDATE NOWAIT prevents concurrent batch processing
- All state transitions validate current state before proceeding
- Reset to draft performs complete cleanup (proposals, line states, line assignments)
- All Python files pass syntax validation
</success_criteria>

<output>
After completion, create `.planning/phases/03-batch-processing-state-management/03-01-SUMMARY.md`
</output>
