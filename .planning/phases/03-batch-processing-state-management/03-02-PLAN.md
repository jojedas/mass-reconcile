---
phase: 03-batch-processing-state-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - models/mass_reconcile_batch.py
  - models/mass_reconcile_match.py
autonomous: true

must_haves:
  truths:
    - "System displays matching statistics: safe count, probable count, doubtful count, unmatched count"
    - "System shows progress text like '42/80 processed - 85% complete'"
    - "Statistics use _read_group for batch performance (no N+1 queries)"
    - "All match proposals stored in batch for audit trail"
  artifacts:
    - path: "models/mass_reconcile_batch.py"
      provides: "Statistics computed fields and progress text"
      contains: "_compute_match_statistics"
    - path: "models/mass_reconcile_match.py"
      provides: "Match model with confidence_class for statistics grouping"
      contains: "confidence_class"
  key_links:
    - from: "models/mass_reconcile_batch.py"
      to: "mass.reconcile.match"
      via: "_read_group grouped by confidence_class"
      pattern: "_read_group.*confidence_class"
    - from: "models/mass_reconcile_batch.py"
      to: "account.bank.statement.line"
      via: "_read_group grouped by match_state for unmatched count"
      pattern: "_read_group.*match_state"
---

<objective>
Add computed statistics fields (safe_match_count, probable_match_count, doubtful_match_count, unmatched_line_count) and progress tracking text field to mass.reconcile.batch using _read_group pattern for performance.

Purpose: Enable users to see matching distribution and processing progress at a glance (BATCH-04, BATCH-05).
Output: Enhanced batch model with statistics and progress fields, ready for Phase 4 UI views.
</objective>

<execution_context>
@/home/jojeda/.claude/get-shit-done/workflows/execute-plan.md
@/home/jojeda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-batch-processing-state-management/03-RESEARCH.md
@.planning/phases/01-foundation-models-data-layer/01-01-SUMMARY.md
@models/mass_reconcile_batch.py
@models/mass_reconcile_match.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add matching statistics computed fields using _read_group</name>
  <files>models/mass_reconcile_batch.py</files>
  <action>
Add four new computed fields to MassReconcileBatch class (place after existing matched_percentage field):

```python
safe_match_count = fields.Integer(
    string='Safe Matches',
    compute='_compute_match_statistics',
    store=True,
    help='Number of statement lines with safe matches (score = 100%)'
)
probable_match_count = fields.Integer(
    string='Probable Matches',
    compute='_compute_match_statistics',
    store=True,
    help='Number of statement lines with probable matches (score 80-99%)'
)
doubtful_match_count = fields.Integer(
    string='Doubtful Matches',
    compute='_compute_match_statistics',
    store=True,
    help='Number of statement lines with doubtful matches (score < 80%)'
)
unmatched_line_count = fields.Integer(
    string='Unmatched Lines',
    compute='_compute_unmatched_count',
    store=True,
    help='Number of statement lines with no match proposals'
)
```

Add `_compute_match_statistics` method:
1. Decorator: `@api.depends('match_ids.confidence_class')`
2. Handle empty recordset (set all to 0 and return early).
3. Use `self.env['mass.reconcile.match']._read_group()` with:
   - domain: `[('batch_id', 'in', self.ids)]`
   - groupby: `['batch_id', 'confidence_class']`
   - aggregates: `['__count']`
4. Build stats dict mapping `batch.id -> {'safe': N, 'probable': N, 'doubtful': N}`.
5. Note: _read_group returns tuples of `((batch_record, confidence_class_value), count)`. Iterate with: `for batch_rec, conf_class, count in counts_data:` and populate stats dict.
6. Assign to each batch record.

Add `_compute_unmatched_count` method:
1. Decorator: `@api.depends('statement_line_ids.match_state')`
2. Handle empty recordset.
3. Use `self.env['account.bank.statement.line']._read_group()` with:
   - domain: `[('batch_id', 'in', self.ids), ('match_state', '=', 'unmatched')]`
   - groupby: `['batch_id']`
   - aggregates: `['__count']`
4. Map results and assign to each batch.

Follow the EXACT same _read_group pattern used in existing `_compute_line_count` and `_compute_match_count` methods for consistency.
  </action>
  <verify>
Run: `python3 -c "import ast; ast.parse(open('models/mass_reconcile_batch.py').read()); print('OK')"`
Verify: `grep -c 'safe_match_count\|probable_match_count\|doubtful_match_count\|unmatched_line_count' models/mass_reconcile_batch.py` returns >= 4
Verify: `grep -c '_compute_match_statistics' models/mass_reconcile_batch.py` returns >= 2 (field def + method)
Verify: `grep -c '_read_group' models/mass_reconcile_batch.py` returns >= 4 (existing 2 + new 2)
  </verify>
  <done>
Four new computed fields (safe_match_count, probable_match_count, doubtful_match_count, unmatched_line_count) using _read_group pattern. Statistics derived from mass.reconcile.match grouped by confidence_class and from statement lines filtered by match_state='unmatched'.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add progress_text computed field and matching_summary_text</name>
  <files>models/mass_reconcile_batch.py</files>
  <action>
Add two computed display fields to MassReconcileBatch (place after unmatched_line_count):

```python
progress_text = fields.Char(
    string='Progress',
    compute='_compute_progress_text',
    help='Human-readable progress indicator'
)
matching_summary_text = fields.Text(
    string='Matching Summary',
    compute='_compute_matching_summary_text',
    help='Summary of matching statistics as percentages'
)
```

Add `_compute_progress_text` method:
1. Decorator: `@api.depends('state', 'line_count', 'match_count')`
2. For each batch:
   - If state == 'draft': `progress_text = "Draft - {line_count} lines loaded" if line_count > 0 else "Draft - No lines loaded"`
   - If state == 'matching': `progress_text = f"{match_count}/{line_count} processed - {int((match_count / line_count) * 100) if line_count else 0}% complete"`
   - If state == 'review': `progress_text = f"Review - {line_count} lines, {match_count} matches"`
   - If state == 'reconciled': `progress_text = "Reconciled"`

Add `_compute_matching_summary_text` method:
1. Decorator: `@api.depends('safe_match_count', 'probable_match_count', 'doubtful_match_count', 'unmatched_line_count', 'line_count')`
2. For each batch:
   - If line_count == 0: set to "No lines loaded"
   - Else: Build multiline string with percentage for each category:
     ```
     safe_pct = round(safe_match_count / line_count * 100, 1) if line_count else 0
     probable_pct = round(probable_match_count / line_count * 100, 1) if line_count else 0
     doubtful_pct = round(doubtful_match_count / line_count * 100, 1) if line_count else 0
     unmatched_pct = round(unmatched_line_count / line_count * 100, 1) if line_count else 0
     ```
     Format: `f"Automatic (safe): {safe_match_count} ({safe_pct}%)\nManual review (probable): {probable_match_count} ({probable_pct}%)\nDoubtful: {doubtful_match_count} ({doubtful_pct}%)\nUnmatched: {unmatched_line_count} ({unmatched_pct}%)"`

These are NOT stored fields (no `store=True`) since they are pure display computations derived from stored statistics.
  </action>
  <verify>
Run: `python3 -c "import ast; ast.parse(open('models/mass_reconcile_batch.py').read()); print('OK')"`
Verify: `grep -c 'progress_text' models/mass_reconcile_batch.py` returns >= 2
Verify: `grep -c 'matching_summary_text' models/mass_reconcile_batch.py` returns >= 2
Verify: `grep -c '_compute_progress_text\|_compute_matching_summary_text' models/mass_reconcile_batch.py` returns >= 2
  </verify>
  <done>
progress_text field shows state-aware progress (e.g., "42/80 processed - 53% complete" during matching, "Review - 80 lines, 65 matches" in review). matching_summary_text field shows statistics with percentages (automatic/manual/doubtful/unmatched breakdown). Both are non-stored computed fields for display purposes.
  </done>
</task>

</tasks>

<verification>
1. `python3 -c "import ast; ast.parse(open('models/mass_reconcile_batch.py').read()); print('SYNTAX OK')"` passes
2. `python3 -c "import ast; ast.parse(open('models/mass_reconcile_match.py').read()); print('SYNTAX OK')"` passes
3. `grep '_read_group' models/mass_reconcile_batch.py` shows 4+ usages (2 existing + 2 new)
4. Statistics fields: safe_match_count, probable_match_count, doubtful_match_count, unmatched_line_count all present
5. Progress fields: progress_text, matching_summary_text both present with compute methods
6. All new computed fields that use _read_group are store=True; display-only fields are not stored
</verification>

<success_criteria>
- safe_match_count, probable_match_count, doubtful_match_count computed from _read_group on match confidence_class
- unmatched_line_count computed from _read_group on statement lines with match_state='unmatched'
- progress_text shows state-appropriate progress message
- matching_summary_text shows percentage breakdown of matching categories
- All _read_group patterns follow existing codebase convention (empty recordset guard, dict mapping)
- All Python files pass syntax validation
</success_criteria>

<output>
After completion, create `.planning/phases/03-batch-processing-state-management/03-02-SUMMARY.md`
</output>
